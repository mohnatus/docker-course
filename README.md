# DOCKER для начинающих

Первые шаги в изучении Docker

Курс (Владилен Минин): https://youtu.be/n9uCgUzfeRQ?si=3CGIxSsE3C7eaj_H
Конспект автора: https://vladilen.notion.site/Docker-2021-a72201ec8573461c8a2e62e2fcf33aa3
Приложение: https://github.com/vladilenm/logs-app

## Идея

Берем работающее приложение (Express) и упаковываем его в docker-образ. 

Результат: приложение можно запустить где угодно без предварительной установки.

## Описание приложения

1. Поднимаем сервер на Express
2. Добавляем корневую страницу с формой. В форму можно ввести любой текст.
3. При отправке формы текст будет записан в файл `data/logs.txt`. Страница при этом перезагружается.
4. При перезагрузке на страницу выводятся все ранее записанные в файл строки. 
5. Для оформления страницы используется шаблонизатор ejs.
6. Приложение запускается на 3000 порту: localhost:3000/. Команда `npm start`.

## Основные понятия

- Образ - шаблон проекта (не изменяется). На основе одного образа можно создать много контейнеров.
- Контейнер - работающий экземпляр образа, где происходит вся работа. Здесь могут происходить изменения, и они НЕ затрагивают исходный образ.

## Этапы работы

### 1. Создать работающее приложение

Тег `v1-project` 

### 2. Описать инструкции для создания образа

Тег `v2-dockerfile`

Dockerfile:

```
# базовый образ, поверх которого будет создан образ приложения
FROM node

# корневая директория внутри образа
WORKDIR /app

# копируем файлы проекта внутрь образа 
COPY . .

# команда выполняется при создании образа
RUN npm install 

# слушать порт 3000 внутри образа
EXPOSE 3000

# команда выполняется при запуске образа
CMD ["node", "app.js"]
```

Собрать образ:

```
docker build .
```

Найти образ в списке: 

```
docker image ls
```

Запустить контейнер из собранного образа:

```
docker run -d -p 80:3000 [image_id]
```

- d (detached) без погружения в контейнер
- p (port) - проброс порта

После этого приложение заработает (на 80 порту).

Посмотреть контейнеры:

```
docker ps -a
```

Остановить контейнер:

```
docker stop [container_id]
```

### 3. Оптимизация создания образа

Тег `v3-optimization`

Было:

```
COPY . .
RUN npm install
```

Сначала копировали все файлы, потом выполняли `npm install`.

Стало:

```
COPY package.json /app
RUN npm install 
COPY . .
```

Сначала копируем package.json.

Если package.json не изменился, то пакеты не будут устанавливаться заново.

Это видно, если запустить `docker build .`. В первый раз команда выполняется, во второй - уже нет, так как файл package.json не изменялся.

### 4. Публикация пакета

Тег `v2-publish`

Залогиниться в docker hub:

```
docker login
```

Имя пакета должно начинаться с имени аккаунта. Нужно переименовать:

```
docker tag [old_name] [new_name]
docker tag [image_id] meeeowth/docker
```

Опубликовать пакет:

```
docker push [account_name/repo_name:repo_tag]
docker push meeeowth/docker
```

Пакет появился в профиле на docker hub: https://hub.docker.com/u/meeeowth

Теперь его можно скачать на другой машине и запустить проект, ничего не устанавливая.

```
docker pull meeeowth/docker
docker run -d -p 80:3000 meeeowth/docker
```

### 5. Переменные окружения

Тег `v5-env`

Адрес порта, который слушается внутри контейнера, сейчас прописан хардкодом в Dockerfile:

```
EXPOSE 3000
```

Лучше брать его из окружения:

```
ENV PORT 3000 # переменная PORT, по дефолту 3000
EXPOSE $PORT
```

Теперь при запуске контейнера можно указать любой порт (внутри контейнера):

```
docker run -d -e PORT=80 -p 3000:80 [image_id]
```

Другой способ указать переменные окружения - в отдельном файле:

```
docker run -d --env-file ./config/.env -p 3000:80 [image_id]
```

### 6. Volume

Тег `v6-volumes`

Пока контейнер работает, новые логи вписываются в файлик data/logs.txt внутри этого контейнера. Но когда контейнер закрывается, все эти данные пропадают вместе с ним.

Поэтому данные должны быть снаружи контейнера. Для этого существует механизм volumes (внешние хранилища). 

Причем такое хранилище могут вместе использовать несколько контейнеров.

Указать в Dockerfile, для какой папки нужно создать внешнее хранилище:

```
VOLUME ["/app/data"]
```

При запуске:

```
docker run -v logs:/app/data -d -p 80:3000 [image_id]
```

`logs` здесь - это имя, которое будет дано созданному хранилищу.

Теперь контейнер можно остановить, а потом запустить новый с тем же именем хранилища - данные сохранятся. 

Доступ к внешним хранилищам можно получить из интерфейса Docker.
